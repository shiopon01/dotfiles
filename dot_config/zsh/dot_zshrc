#!/bin/sh

# .zshrc for shiopon01

print -n "
TTY      : $TTY
SHLVL    : $SHLVL
HOSTNAME : $HOST
"

## 日本語化
export LANG=ja_JP.UTF-8

## カラー使用
autoload -Uz colors
colors

# WSL2色対応
if [[ -x /usr/bin/dircolors ]]; then
    [[ -r ~/.dircolors ]] && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# colored GCC warnings and errors
export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

## ls の色を変更
export CLICOLOR=1
export LSCOLORS='exfxcxdxbxGxDxabagacad'
export LS_COLORS='di=34:ln=35:so=32:pi=33:ex=31:bd=36;01:cd=33;01:su=31;40;07:sg=36;40;07:tw=32;40;07:ow=33;40;07:'

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

## zsh-hook 有効化
autoload -Uz add-zsh-hook

## vim 風キーバインドにする
bindkey -e

## 単語の区切り文字指定
autoload -Uz select-word-style
select-word-style default 
zstyle ':zle:*' word-chars ' /=;@:{}[]()<>,|.'
zstyle ':zle:*' word-style unspecified

#####
# 補完

# 補完機能を有効にする
autoload -Uz compinit
compinit

# 補完で小文字でも大文字にマッチさせる
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'

# ../ の後は今いるディレクトリを補完しない
zstyle ':completion:*' ignore-parents parent pwd ..

# sudo の後ろでコマンド名を補完する
zstyle ':completion:*:sudo:*' command-path /usr/local/sbin /usr/local/bin \
/usr/sbin /usr/bin /sbin /bin /usr/X11R6/bin

# ps コマンドのプロセス名補完
zstyle ':completion:*:processes' command 'ps x -o pid,s,args'

# 補完を矢印キー対応
zstyle ':completion:*:default' menu select=2

# 補完を過剰にする
zstyle ':completion:*' verbose yes
zstyle ':completion:*' completer _expand _complete _match _prefix _approximate _list _history
zstyle ':completion:*:messages' format '%F{3}%d%f'
zstyle ':completion:*:warnings' format '%F{1}No matches for:%f%F{3} %d%f'
zstyle ':completion:*:descriptions' format '%F{3}completing %B%d%b%f'
zstyle ':completion:*:corrections' format '%F{1}%B%d (errors: %e)%b%f'
zstyle ':completion:*:options' description 'yes'

# グループ名に空文字列を指定すると，マッチ対象のタグ名がグループ名に使われる。
# # したがって，すべての マッチ種別を別々に表示させたいなら以下のようにする
zstyle ':completion:*' group-name ''

# apt-get などをキャッシュ
zstyle ':completion:*' use-cache true

# ファイル補完候補に色を付ける
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}

# history

## 履歴ファイルの保存先
export HISTFILE=${HOME}/.zsh_history

## メモリに保存される履歴の件数
export HISTSIZE=1000

## 履歴ファイルに保存される履歴の件数
export SAVEHIST=100000

# setopt
setopt correct               # もしかして機能
setopt re_match_pcre         # PCRE 互換の正規表現を使う
setopt prompt_subst          # プロンプトが表示されるたびにプロンプト文字列を評価、置換する
setopt print_eight_bit       # 日本語ファイル名を表示可能にする
setopt no_beep               # beep を無効にする
setopt no_flow_control       # フローコントロールを無効にする
setopt auto_cd               # ディレクトリ名だけでcdする
setopt auto_pushd            # cd したら自動的に pushd する
setopt pushd_ignore_dups     # 重複したディレクトリを追加しない
setopt share_history         # 同時に起動したzshの間でヒストリを共有する
setopt hist_ignore_all_dups  # 同じコマンドをヒストリに残さない
setopt hist_save_nodups      # ヒストリファイルに保存するとき、すでに重複したコマンドがあったら古い方を削除する
setopt hist_ignore_space     # スペースから始まるコマンド行はヒストリに残さない
setopt hist_reduce_blanks    # ヒストリに保存するときに余分なスペースを削除する
setopt extended_glob         # 高機能なワイルドカード展開を使用する
setopt EXTENDED_HISTORY      # 開始と終了を記録
## 補完
setopt auto_param_slash      # ディレクトリ名の補完で末尾の / を自動的に付加し、次の補完に備える
setopt mark_dirs             # ファイル名の展開でディレクトリにマッチした場合 末尾に / を付加
setopt list_types            # 補完候補一覧でファイルの種別を識別マーク表示 (訳注:ls -F の記号)
setopt auto_menu             # 補完キー連打で順に補完候補を自動で補完
setopt auto_param_keys       # カッコの対応などを自動的に補完
setopt interactive_comments  # コマンドラインでも # 以降をコメントと見なす
setopt magic_equal_subst     # コマンドラインの引数で --prefix=/usr などの =以降でも補完できる
setopt complete_in_word      # 語の途中でもカーソル位置で補完
setopt always_last_prompt    # カーソル位置は保持したままファイル名一覧を順次その場で表示
bindkey "^I" menu-complete   # 展開する前に補完候補を出させる(Ctrl-iで補完するようにする)

# ^R で履歴検索をするときに * でワイルドカードを使用出来るようにする
bindkey '^R' history-incremental-pattern-search-backward
bindkey '^S' history-incremental-pattern-search-forward

# vcs_info
autoload -Uz vcs_info
setopt prompt_subst
zstyle ':vcs_info:git:*' check-for-changes true
zstyle ':vcs_info:git:*' stagedstr "%F{yellow}!"
zstyle ':vcs_info:git:*' unstagedstr "%F{red}+"
zstyle ':vcs_info:*' formats "%F{green}%c%u[%b]%f (%m)" # %m が git user.email
zstyle ':vcs_info:*' actionformats '[%b|%a] %m'

_vcs_precmd () { vcs_info }
add-zsh-hook precmd _vcs_precmd

zstyle ':vcs_info:git+set-message:*' hooks git-config-user # git リポジトリの時 set-message フックで git-config-user 呼び出し

function +vi-git-config-user(){
  hook_com[misc]+=`git config user.email`
}

# PROMPT
PROMPT='
%F{cyan}%*%f %F{green}%n@%m%f %F{yellow}%~%f[%h] ${vcs_info_msg_0_}
%# '
SPROMPT="%F{red}(*'~'%)? もしかして %B%r%b %F{red}かな? [そう!(y), 違う!(n)]:%f "

# ghq + fzf
function ghq() {
  if [ $# -eq 0 ]; then
    local repo_path
    repo_path=$(ghq list | fzf --height 40% --reverse)
    if [[ -n "$repo_path" ]]; then
      cd "$(ghq root)/$repo_path"
      echo "jump to $(ghq root)/$repo_path"
    fi
  else
    command ghq "$@"
  fi
}

# ghq + peco
# function re {
#   local path=$(ghq list --full-path | peco --query "$LBUFFER")
#   if [ -n "$path" ]; then
#     if [ -t 1 ]; then
#       cd ${path}
#       echo 'jump to' ${path}
#     fi
#   fi
# }


# C で標準出力をクリップボードにコピー
# ref: http://mollifier.hatenablog.com/entry/20100317/p1
if which pbcopy >/dev/null 2>&1 ; then
  # Mac
  alias -g C='| pbcopy'
elif which xsel >/dev/null 2>&1 ; then
  # Linux
  alias -g C='| xsel --input --clipboard'
elif which putclip >/dev/null 2>&1 ; then
  # Cygwin
  alias -g C='| putclip'
fi


# other import configs
#[ -f $ZDOTDIR/.zshrc_os_`uname` ] && . $ZDOTDIR/.zshrc_os_`uname`
#[ -f $ZDOTDIR/.zshrc_local ] && . $ZDOTDIR/.zshrc_local
